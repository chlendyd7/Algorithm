'''
💡 핵심 아이디어: "쓸모없는 탑은 버린다"
오른쪽으로 가면서 새로운 탑을 확인할 때, 현재 탑보다 낮은 왼쪽에 있는 탑들은 앞으로 나타날 탑들의 신호를 수신할 가능성이 전혀 없습니다. 현재 탑이 그 뒤의 모든 신호를 가로막기 때문이죠.

스택의 구성: 스택에는 (탑의 높이, 탑의 인덱스)를 저장합니다.

순차 탐색: 왼쪽부터 오른쪽으로 탑을 하나씩 확인합니다.

스택 비교 (핵심 로직):

스택이 비어있다면: 왼쪽에 수신할 탑이 없으므로 0을 출력하고, 현재 탑을 스택에 넣습니다.

스택의 top(가장 최근 탑)이 현재보다 낮다면: 그 탑은 앞으로도 쓸모가 없으므로 스택에서 pop하여 제거합니다. (이 과정을 반복)

스택의 top이 현재보다 높다면: 이 탑이 바로 현재 신호를 수신하는 탑입니다! top의 인덱스를 출력하고, 현재 탑을 스택에 추가합니다.
'''

N = int(input())
tops = list(map(int, input().split()))
result = [0] * N
stack = [] # (높이, 인덱스)

for i in range(N):
    now_top = tops[i]
    
    # 현재 탑보다 낮은 탑들은 신호를 수신할 수 없으므로 모두 제거
    while stack and stack[-1][0] < now_top:
        stack.pop()
    
    # 스택에 남아있는 가장 위의 탑이 신호를 수신하는 탑
    if stack:
        result[i] = stack[-1][1] + 1
    
    # 현재 탑을 스택에 추가
    stack.append((now_top, i))

# 리스트 요소를 공백으로 구분하여 출력
print(*(result))