def odnum(n, nums):
    result = [-1] * n
    stack = []
    count = dict()
    for i in range(n):
        if nums[i] in count:
            count[nums[i]] += 1
        else:
            count[nums[i]] = 1
    
    for i in range(n):
        while stack and count[stack[-1]] < count[nums[i]]:
            index = stack.pop()
            result[index] = count[nums[i]]
        stack.append(i)
    
    return result

n = int(input())
nums = list(map(int,input().split()))

print(' '.join(map(str, odnum(n, nums))))

'''
오등큰수를 찾기 위해 오른쪽에서 왼쪽으로 스캔하는 것과 왼쪽에서 오른쪽으로 스캔하는 두 가지 방법을 예시를 통해 비교해보겠습니다.

예제 입력
수열: [1, 1, 2, 3, 4, 2, 1]

오른쪽에서 왼쪽으로 스캔하는 방법
빈도 계산:

python
코드 복사
freq = {1: 3, 2: 2, 3: 1, 4: 1}
스캔 및 결과 계산:

초기 상태: result = [-1, -1, -1, -1, -1, -1, -1], stack = []

i = 6 (a[6] = 1): 스택이 비어 있으므로 오등큰수는 없음. stack = [1]

i = 5 (a[5] = 2): 빈도 2 <= 3이므로 스택에서 pop. 오등큰수는 없음. stack = [2]

i = 4 (a[4] = 4): 빈도 1 <= 2이므로 스택에 그대로 유지. 오등큰수는 2. result[4] = 2, stack = [2, 4]

i = 3 (a[3] = 3): 빈도 1 <= 1이므로 스택에서 pop. 오등큰수는 2. result[3] = 2, stack = [2, 3]

i = 2 (a[2] = 2): 빈도 2 <= 2이므로 스택에서 pop. 오등큰수는 1. result[2] = 1, stack = [2]

i = 1 (a[1] = 1): 빈도 3 <= 2이므로 스택에서 pop. 오등큰수는 없음. stack = [1]

i = 0 (a[0] = 1): 빈도 3 <= 3이므로 스택에서 pop. 오등큰수는 없음. stack = [1]

최종 결과: result = [-1, -1, 1, 2, 2, 1, -1]

왼쪽에서 오른쪽으로 스캔하는 방법
왼쪽에서 오른쪽으로 스캔하는 방법을 시도하면, 더 복잡한 처리가 필요합니다. 현재 수의 오등큰수를 찾기 위해 앞으로 올 수들을 모두 확인해야 하므로, 이 방법은 비효율적입니다. 오등큰수를 효율적으로 찾기 위해 여전히 스택을 사용할 수 있지만, 전체적인 처리 과정이 더 복잡해질 수 있습니다.

빈도 계산:

python
코드 복사
freq = {1: 3, 2: 2, 3: 1, 4: 1}
스캔 및 결과 계산:

초기 상태: result = [-1, -1, -1, -1, -1, -1, -1], stack = []

i = 0 (a[0] = 1): 스택이 비어 있으므로 현재 수를 스택에 추가. stack = [1]

i = 1 (a[1] = 1): 현재 수를 스택에 추가. stack = [1, 1]

i = 2 (a[2] = 2): 빈도 2 > 1. 스택을 비우고, 오등큰수는 2. result[1] = 2, stack = [2]

i = 3 (a[3] = 3): 빈도 1 <= 2. 현재 수를 스택에 추가. stack = [2, 3]

i = 4 (a[4] = 4): 빈도 1 <= 1. 현재 수를 스택에 추가. stack = [2, 3, 4]

i = 5 (a[5] = 2): 빈도 2 > 1. 스택을 비우고, 오등큰수는 2. result[4] = 2, stack = [2]

i = 6 (a[6] = 1): 빈도 3 > 2. 스택을 비우고, 오등큰수는 없음. stack = [1]

최종 결과: result = [-1, 2, -1, 2, 2, -1, -1]

이 경우, 스택을 비우는 과정이 매우 복잡해지고, 오른쪽에서 왼쪽으로 스캔하는 것보다 비효율적입니다.

결론
오른쪽에서 왼쪽으로 스캔하는 것이 더 직관적이고 효율적인 이유는 스택을 사용하여 각 수의 오등큰수를 쉽게 찾을 수 있기 때문입니다. 스택을 사용하면 오른쪽에서 왼쪽으로 스캔하면서 더 큰 빈도의 수를 빠르게 찾을 수 있으며, 이로 인해 전체 시간 복잡도가 O(N)으로 유지됩니다. 왼쪽에서 오른쪽으로 스캔하는 방법은 같은 시간 복잡도를 가질 수 있지만, 코드가 복잡해지고 직관적이지 않으며, 추가적인 데이터를 관리하는 데 어려움이 있을 수 있습니다.
'''